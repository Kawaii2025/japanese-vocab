import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import pool from './db.js';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// ‰∏≠Èó¥‰ª∂
app.use(cors({
  origin: process.env.CORS_ORIGIN?.split(',') || '*'
}));
app.use(express.json());

// ==================== ÂçïËØçÁõ∏ÂÖ≥ API ====================

// Ëé∑ÂèñÊâÄÊúâÂçïËØçÔºàÂ∏¶ÂàÜÈ°µÔºåÈªòËÆ§Á¨¨‰∏ÄÈ°µÔºâ
app.get('/api/vocabulary', async (req, res) => {
  try {
    const { category, difficulty, page, pageSize, limit, offset } = req.query;
    
    // ÊûÑÂª∫ WHERE Êù°‰ª∂
    let whereClause = 'WHERE 1=1';
    const params = [];
    let paramIndex = 1;
    
    if (category) {
      whereClause += ` AND category = $${paramIndex}`;
      params.push(category);
      paramIndex++;
    }
    
    if (difficulty) {
      whereClause += ` AND difficulty <= $${paramIndex}`;
      params.push(difficulty);
      paramIndex++;
    }
    
    // 1. ÂÖàÊü•ËØ¢ÊÄªÊï∞
    const countQuery = `SELECT COUNT(*) FROM vocabulary ${whereClause}`;
    const countResult = await pool.query(countQuery, params);
    const totalCount = parseInt(countResult.rows[0].count);
    
    // 2. ËÆ°ÁÆóÂàÜÈ°µÂèÇÊï∞ÔºàÈªòËÆ§ÔºöÁ¨¨1È°µÔºåÊØèÈ°µ20Êù°Ôºâ
    let actualLimit, actualOffset, currentPage;
    
    // ‰ºòÂÖà‰ΩøÁî® page/pageSizeÔºàÊé®ËçêÔºâÔºåÂê¶Âàô‰ΩøÁî® limit/offsetÔºàÂÖºÂÆπÊóßÁâàÔºâ
    if (limit !== undefined || offset !== undefined) {
      // ÂÖºÂÆπÊóßÁâà API
      actualLimit = limit ? parseInt(limit) : 20;
      actualOffset = offset ? parseInt(offset) : 0;
      currentPage = Math.floor(actualOffset / actualLimit) + 1;
    } else {
      // ‰ΩøÁî®È°µÁ†ÅÂàÜÈ°µÔºàÈªòËÆ§Á¨¨1È°µÔºåÊØèÈ°µ20Êù°Ôºâ
      currentPage = page ? parseInt(page) : 1;
      const currentPageSize = pageSize ? parseInt(pageSize) : 20;
      actualLimit = currentPageSize;
      actualOffset = (currentPage - 1) * currentPageSize;
    }
    
    // 3. Êü•ËØ¢Êï∞ÊçÆÔºàÂßãÁªà‰ΩøÁî®ÂàÜÈ°µÔºåÈò≤Ê≠¢ÊÄßËÉΩÈóÆÈ¢òÔºâ
    const dataQuery = `
      SELECT * FROM vocabulary 
      ${whereClause}
      ORDER BY id
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    const dataParams = [...params, actualLimit, actualOffset];
    const dataResult = await pool.query(dataQuery, dataParams);
    
    // 4. ËÆ°ÁÆóÂàÜÈ°µ‰ø°ÊÅØ
    const totalPages = Math.ceil(totalCount / actualLimit);
    
    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        total: totalCount,           // ÊÄªËÆ∞ÂΩïÊï∞
        page: currentPage,            // ÂΩìÂâçÈ°µÁ†Å
        pageSize: actualLimit,        // ÊØèÈ°µÊù°Êï∞
        totalPages: totalPages,       // ÊÄªÈ°µÊï∞
        hasNext: currentPage < totalPages,    // ÊòØÂê¶Êúâ‰∏ã‰∏ÄÈ°µ
        hasPrev: currentPage > 1              // ÊòØÂê¶Êúâ‰∏ä‰∏ÄÈ°µ
      }
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂçïËØçÂàóË°®Â§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂçïËØçÂàóË°®Â§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÂçï‰∏™ÂçïËØç
app.get('/api/vocabulary/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      'SELECT * FROM vocabulary WHERE id = $1',
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'ÂçïËØç‰∏çÂ≠òÂú®'
      });
    }
    
    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂçïËØçÂ§±Ë¥•'
    });
  }
});

// ÈöèÊú∫Ëé∑ÂèñÂçïËØçÔºàÁî®‰∫éÁªÉ‰π†Ôºâ
app.get('/api/vocabulary/random/:count', async (req, res) => {
  try {
    const { count } = req.params;
    const { category, difficulty } = req.query;
    
    let query = 'SELECT * FROM vocabulary WHERE 1=1';
    const params = [];
    let paramIndex = 1;
    
    if (category) {
      query += ` AND category = $${paramIndex}`;
      params.push(category);
      paramIndex++;
    }
    
    if (difficulty) {
      query += ` AND difficulty <= $${paramIndex}`;
      params.push(difficulty);
      paramIndex++;
    }
    
    query += ` ORDER BY RANDOM() LIMIT $${paramIndex}`;
    params.push(count);
    
    const result = await pool.query(query, params);
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÈöèÊú∫ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÈöèÊú∫ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// ÊêúÁ¥¢ÂçïËØçÔºàÂ∏¶ÂàÜÈ°µÔºâ
app.get('/api/vocabulary/search/:keyword', async (req, res) => {
  try {
    const { keyword } = req.params;
    const { page = 1, pageSize = 20 } = req.query;
    
    const searchPattern = `%${keyword}%`;
    
    // 1. Êü•ËØ¢ÊÄªÊï∞
    const countResult = await pool.query(
      `SELECT COUNT(*) FROM vocabulary 
       WHERE chinese LIKE $1 OR kana LIKE $1 OR original LIKE $1`,
      [searchPattern]
    );
    const totalCount = parseInt(countResult.rows[0].count);
    
    // 2. ËÆ°ÁÆóÂàÜÈ°µ
    const currentPage = parseInt(page);
    const currentPageSize = parseInt(pageSize);
    const offset = (currentPage - 1) * currentPageSize;
    
    // 3. Êü•ËØ¢Êï∞ÊçÆ
    const result = await pool.query(
      `SELECT * FROM vocabulary 
       WHERE chinese LIKE $1 OR kana LIKE $1 OR original LIKE $1
       ORDER BY id
       LIMIT $2 OFFSET $3`,
      [searchPattern, currentPageSize, offset]
    );
    
    // 4. ËÆ°ÁÆóÂàÜÈ°µ‰ø°ÊÅØ
    const totalPages = Math.ceil(totalCount / currentPageSize);
    
    res.json({
      success: true,
      data: result.rows,
      keyword: keyword,
      pagination: {
        total: totalCount,
        page: currentPage,
        pageSize: currentPageSize,
        totalPages: totalPages,
        hasNext: currentPage < totalPages,
        hasPrev: currentPage > 1
      }
    });
  } catch (error) {
    console.error('ÊêúÁ¥¢ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'ÊêúÁ¥¢ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// ÂàõÂª∫ÂçïËØç
app.post('/api/vocabulary', async (req, res) => {
  try {
    const { chinese, original, kana, category, difficulty } = req.body;
    
    if (!chinese || !kana) {
      return res.status(400).json({
        success: false,
        error: '‰∏≠ÊñáÊÑèÊÄùÂíåÂÅáÂêç‰∏çËÉΩ‰∏∫Á©∫'
      });
    }
    
    const result = await pool.query(
      `INSERT INTO vocabulary (chinese, original, kana, category, difficulty)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [chinese, original, kana, category || null, difficulty || 1]
    );
    
    res.status(201).json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('ÂàõÂª∫ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'ÂàõÂª∫ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// ÊâπÈáèÂàõÂª∫ÂçïËØç
app.post('/api/vocabulary/batch', async (req, res) => {
  try {
    const { words } = req.body;
    
    if (!Array.isArray(words) || words.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'ÂçïËØçÂàóË°®‰∏çËÉΩ‰∏∫Á©∫'
      });
    }
    
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      const insertedWords = [];
      for (const word of words) {
        const { chinese, original, kana, category, difficulty } = word;
        
        if (!chinese || !kana) continue;
        
        const result = await client.query(
          `INSERT INTO vocabulary (chinese, original, kana, category, difficulty)
           VALUES ($1, $2, $3, $4, $5)
           RETURNING *`,
          [chinese, original, kana, category || null, difficulty || 1]
        );
        
        insertedWords.push(result.rows[0]);
      }
      
      await client.query('COMMIT');
      
      res.status(201).json({
        success: true,
        data: insertedWords,
        total: insertedWords.length
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('ÊâπÈáèÂàõÂª∫ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'ÊâπÈáèÂàõÂª∫ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Êõ¥Êñ∞ÂçïËØç
app.put('/api/vocabulary/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { chinese, original, kana, category, difficulty } = req.body;
    
    const result = await pool.query(
      `UPDATE vocabulary 
       SET chinese = $1, original = $2, kana = $3, category = $4, difficulty = $5
       WHERE id = $6
       RETURNING *`,
      [chinese, original, kana, category, difficulty, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'ÂçïËØç‰∏çÂ≠òÂú®'
      });
    }
    
    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Êõ¥Êñ∞ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Êõ¥Êñ∞ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Âà†Èô§ÂçïËØç
app.delete('/api/vocabulary/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      'DELETE FROM vocabulary WHERE id = $1 RETURNING *',
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'ÂçïËØç‰∏çÂ≠òÂú®'
      });
    }
    
    res.json({
      success: true,
      message: 'Âà†Èô§ÊàêÂäü'
    });
  } catch (error) {
    console.error('Âà†Èô§ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Âà†Èô§ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// ==================== ÂàÜÁ±ªÁõ∏ÂÖ≥ API ====================

// Ëé∑ÂèñÊâÄÊúâÂàÜÁ±ª
app.get('/api/categories', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT DISTINCT category FROM vocabulary WHERE category IS NOT NULL ORDER BY category'
    );
    
    res.json({
      success: true,
      data: result.rows.map(row => row.category)
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂàÜÁ±ªÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂàÜÁ±ªÂ§±Ë¥•'
    });
  }
});

// ==================== ÂÅ•Â∫∑Ê£ÄÊü• ====================

app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'API ËøêË°åÊ≠£Â∏∏',
    timestamp: new Date().toISOString()
  });
});

// ÂêØÂä®ÊúçÂä°Âô®
app.listen(PORT, () => {
  console.log(`üöÄ ÊúçÂä°Âô®ËøêË°åÂú® http://localhost:${PORT}`);
  console.log(`üìö API ÊñáÊ°£: http://localhost:${PORT}/api`);
});

// ==================== Êó•ÊúüÁõ∏ÂÖ≥ API ====================

// Ëé∑Âèñ‰ªäÊó•ÂΩïÂÖ•ÁöÑÂçïËØç
app.get('/api/vocabulary/today', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM vocabulary WHERE input_date = CURRENT_DATE ORDER BY created_at DESC'
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount
    });
  } catch (error) {
    console.error('Ëé∑Âèñ‰ªäÊó•ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑Âèñ‰ªäÊó•ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÊåáÂÆöÊó•ÊúüÁöÑÂçïËØç
app.get('/api/vocabulary/by-date/:date', async (req, res) => {
  try {
    const { date } = req.params;
    const result = await pool.query(
      'SELECT * FROM vocabulary WHERE input_date = $1 ORDER BY created_at DESC',
      [date]
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount,
      date: date
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊåáÂÆöÊó•ÊúüÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÊåáÂÆöÊó•ÊúüÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÊó•ÊúüËåÉÂõ¥ÂÜÖÁöÑÂçïËØç
app.get('/api/vocabulary/date-range', async (req, res) => {
  try {
    const { start, end } = req.query;
    
    if (!start || !end) {
      return res.status(400).json({
        success: false,
        error: 'ËØ∑Êèê‰æõ start Âíå end ÂèÇÊï∞'
      });
    }
    
    const result = await pool.query(
      'SELECT * FROM vocabulary WHERE input_date BETWEEN $1 AND $2 ORDER BY input_date DESC, created_at DESC',
      [start, end]
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount,
      dateRange: { start, end }
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊó•ÊúüËåÉÂõ¥ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÊó•ÊúüËåÉÂõ¥ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Ëé∑Âèñ‰ªäÊó•ÂæÖÂ§ç‰π†ÁöÑÂçïËØç
app.get('/api/vocabulary/review/today', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM vocabulary WHERE next_review_date <= CURRENT_DATE ORDER BY next_review_date ASC, mastery_level ASC'
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂæÖÂ§ç‰π†ÂçïËØçÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂæÖÂ§ç‰π†ÂçïËØçÂ§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÊú™Êù•NÂ§©ÁöÑÂ§ç‰π†ËÆ°Âàí
app.get('/api/vocabulary/review/plan', async (req, res) => {
  try {
    const { days = 7 } = req.query;
    const result = await pool.query(
      `SELECT 
        next_review_date as date,
        COUNT(*) as word_count,
        json_agg(json_build_object('id', id, 'chinese', chinese, 'kana', kana, 'mastery_level', mastery_level)) as words
      FROM vocabulary 
      WHERE next_review_date BETWEEN CURRENT_DATE AND CURRENT_DATE + $1::integer
      GROUP BY next_review_date
      ORDER BY next_review_date`,
      [days]
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount,
      days: parseInt(days)
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂ§ç‰π†ËÆ°ÂàíÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂ§ç‰π†ËÆ°ÂàíÂ§±Ë¥•'
    });
  }
});

// ËÆ∞ÂΩïÁªÉ‰π†ÁªìÊûúÔºà‰ºöËá™Âä®Ëß¶ÂèëÂ§ç‰π†ËÆ°ÂàíÊõ¥Êñ∞Ôºâ
app.post('/api/practice', async (req, res) => {
  try {
    const { user_id = 1, vocabulary_id, user_answer, is_correct, attempt_count = 1 } = req.body;
    
    if (!vocabulary_id || user_answer === undefined || is_correct === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞Ôºövocabulary_id, user_answer, is_correct'
      });
    }
    
    const result = await pool.query(
      `INSERT INTO practice_records (user_id, vocabulary_id, user_answer, is_correct, attempt_count, practice_date)
       VALUES ($1, $2, $3, $4, $5, CURRENT_DATE)
       RETURNING *`,
      [user_id, vocabulary_id, user_answer, is_correct, attempt_count]
    );
    
    // Ëé∑ÂèñÊõ¥Êñ∞ÂêéÁöÑÂçïËØç‰ø°ÊÅØ
    const vocabResult = await pool.query(
      'SELECT id, chinese, kana, mastery_level, next_review_date, review_count FROM vocabulary WHERE id = $1',
      [vocabulary_id]
    );
    
    res.json({
      success: true,
      data: {
        practice: result.rows[0],
        vocabulary: vocabResult.rows[0]
      },
      message: is_correct ? 'ÂõûÁ≠îÊ≠£Á°ÆÔºÅ' : 'ÁªßÁª≠Âä†Ê≤πÔºÅ'
    });
  } catch (error) {
    console.error('ËÆ∞ÂΩïÁªÉ‰π†Â§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'ËÆ∞ÂΩïÁªÉ‰π†Â§±Ë¥•'
    });
  }
});

// ==================== ÁªüËÆ°Áõ∏ÂÖ≥ API ====================

// Ëé∑ÂèñÊØèÊó•ÂΩïÂÖ•ÁªüËÆ°
app.get('/api/stats/daily-input', async (req, res) => {
  try {
    const { days = 30 } = req.query;
    const result = await pool.query(
      `SELECT 
        input_date,
        COUNT(*) as word_count,
        COUNT(CASE WHEN mastery_level >= 3 THEN 1 END) as mastered_count
      FROM vocabulary
      WHERE input_date >= CURRENT_DATE - $1::integer
      GROUP BY input_date
      ORDER BY input_date DESC`,
      [days]
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount,
      days: parseInt(days)
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊØèÊó•ÂΩïÂÖ•ÁªüËÆ°Â§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÊØèÊó•ÂΩïÂÖ•ÁªüËÆ°Â§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÊØèÊó•ÁªÉ‰π†ÁªüËÆ°
app.get('/api/stats/daily-practice', async (req, res) => {
  try {
    const { user_id = 1, days = 30 } = req.query;
    const result = await pool.query(
      `SELECT 
        practice_date,
        COUNT(*) as practice_count,
        SUM(CASE WHEN is_correct THEN 1 ELSE 0 END) as correct_count,
        ROUND(AVG(CASE WHEN is_correct THEN 100.0 ELSE 0 END), 2) as accuracy_rate
      FROM practice_records
      WHERE user_id = $1 AND practice_date >= CURRENT_DATE - $2::integer
      GROUP BY practice_date
      ORDER BY practice_date DESC`,
      [user_id, days]
    );
    
    res.json({
      success: true,
      data: result.rows,
      total: result.rowCount,
      days: parseInt(days)
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊØèÊó•ÁªÉ‰π†ÁªüËÆ°Â§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÊØèÊó•ÁªÉ‰π†ÁªüËÆ°Â§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÊéåÊè°Á®ãÂ∫¶ÂàÜÂ∏É
app.get('/api/stats/mastery-distribution', async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT 
        mastery_level,
        COUNT(*) as word_count,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM vocabulary), 2) as percentage
      FROM vocabulary
      GROUP BY mastery_level
      ORDER BY mastery_level`
    );
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊéåÊè°Á®ãÂ∫¶ÂàÜÂ∏ÉÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÊéåÊè°Á®ãÂ∫¶ÂàÜÂ∏ÉÂ§±Ë¥•'
    });
  }
});

// Ëé∑ÂèñÂ≠¶‰π†Ê¶ÇËßà
app.get('/api/stats/overview', async (req, res) => {
  try {
    const { user_id = 1 } = req.query;
    
    // Ëé∑ÂèñÂ§ö‰∏™ÁªüËÆ°Êï∞ÊçÆ
    const [totalWords, todayInput, todayReview, totalPractice, recentAccuracy] = await Promise.all([
      pool.query('SELECT COUNT(*) as count FROM vocabulary'),
      pool.query('SELECT COUNT(*) as count FROM vocabulary WHERE input_date = CURRENT_DATE'),
      pool.query('SELECT COUNT(*) as count FROM vocabulary WHERE next_review_date <= CURRENT_DATE'),
      pool.query('SELECT COUNT(*) as count FROM practice_records WHERE user_id = $1', [user_id]),
      pool.query(
        `SELECT ROUND(AVG(CASE WHEN is_correct THEN 100.0 ELSE 0 END), 2) as rate
         FROM practice_records 
         WHERE user_id = $1 AND practice_date >= CURRENT_DATE - 7`,
        [user_id]
      )
    ]);
    
    res.json({
      success: true,
      data: {
        totalWords: parseInt(totalWords.rows[0].count),
        todayInput: parseInt(todayInput.rows[0].count),
        todayReview: parseInt(todayReview.rows[0].count),
        totalPractice: parseInt(totalPractice.rows[0].count),
        recentAccuracy: parseFloat(recentAccuracy.rows[0].rate) || 0
      }
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÂ≠¶‰π†Ê¶ÇËßàÂ§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: 'Ëé∑ÂèñÂ≠¶‰π†Ê¶ÇËßàÂ§±Ë¥•'
    });
  }
});

// ‰ºòÈõÖÂÖ≥Èó≠
process.on('SIGINT', async () => {
  console.log('\nÊ≠£Âú®ÂÖ≥Èó≠ÊúçÂä°Âô®...');
  await pool.end();
  process.exit(0);
});
